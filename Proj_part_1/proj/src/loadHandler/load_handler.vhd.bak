library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_unsigned.all; -- For handling unsigned arithmetic

entity load_handler is 
  port (
    DMEM_in : in std_logic_vector(31 downto 0);
    load_control : in std_logic_vector(2 downto 0); -- 000: lw, 001: lb, 010: lh, 011: lbu, 100: lhu
    DMEM_out : out std_logic_vector(31 downto 0);
    offset : in std_logic_vector(1 downto 0)  -- 2-bit offset for byte and half-word access (0-3)
  );
end load_handler;

architecture structural of load_handler is 

-- Intermediate signals for byte/half-word extraction and extension
signal s_lb, s_lh, s_lbu, s_lhu : std_logic_vector(31 downto 0);
signal sign_bit_byte, sign_bit_half : std_logic;
signal byte_value, half_word_value : std_logic_vector(15 downto 0); -- For extracting byte and half-word values

begin

  -- Extract byte or half-word based on offset and extend/sign-extend
  process(DMEM_in, offset)
  begin
    -- Get byte or half-word depending on offset
    case offset is
      when "00" =>  -- Byte at lowest address (0, 1, 2, or 3)
        byte_value <= DMEM_in(7 downto 0);
      when "01" =>  -- Byte at address + 1
        byte_value <= DMEM_in(15 downto 8);
      when "10" =>  -- Byte at address + 2
        byte_value <= DMEM_in(23 downto 16);
      when "11" =>  -- Byte at address + 3
        byte_value <= DMEM_in(31 downto 24);
      when others =>
        byte_value <= (others => '0');
    end case;
  end process;

  -- Sign or zero-extend byte for lb/lbu
  sign_bit_byte <= byte_value(7);  -- For sign extension
  s_lb <= (others => sign_bit_byte) & byte_value when sign_bit_byte = '1' else
          (others => '0') & byte_value; -- Sign-extend for lb

  s_lbu <= (others => '0') & byte_value; -- Zero-extend for lbu

  -- Extract half-word depending on offset (similar to byte extraction)
  process(DMEM_in, offset)
  begin
    case offset is
      when "00" =>  -- Half-word at lowest address (0, 1, 2, or 3)
        half_word_value <= DMEM_in(15 downto 0);
      when "01" =>  -- Half-word at address + 1
        half_word_value <= DMEM_in(23 downto 8);
      when "10" =>  -- Half-word at address + 2
        half_word_value <= DMEM_in(31 downto 16);
      when others =>
        half_word_value <= (others => '0');
    end case;
  end process;

  -- Sign or zero-extend half-word for lh/lhu
  sign_bit_half <= half_word_value(15);  -- For sign extension
  s_lh <= (31 downto 16 => sign_bit_half) & half_word_value when sign_bit_half = '1' else
          (31 downto 16 => '0') & half_word_value; -- Sign-extend for lh

  s_lhu <= (31 downto 16 => '0') & half_word_value; -- Zero-extend for lhu

  -- Load control select logic to choose appropriate output based on load_control
  with load_control select
    DMEM_out <= DMEM_in when "000",  -- lw: full word load
                s_lb when "001",    -- lb: signed byte load with extension
                s_lh when "010",    -- lh: signed half-word load with extension
                s_lbu when "011",   -- lbu: unsigned byte load with zero extension
                s_lhu when "100",   -- lhu: unsigned half-word load with zero extension
                x"00000000" when others; -- Default case for unsupported operations

end structural;

